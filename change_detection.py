# -*- coding: utf-8 -*-
"""Change detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n04_brN2I4_bUyN_k_PKld0C7dyVnrNg
"""

from google.colab import drive
drive.mount("/content/drive")

"""LOADING IMAGES

2006
"""

import os
from PIL import Image

# Define the path to the image dataset (current working directory)
image_dir = '/content/drive/MyDrive/D35(10)/2006'

# Get a list of all image files in the directory
image_files = sorted([f for f in os.listdir(image_dir) if f.endswith('.jpg') or f.endswith('.png')])

# Load the images
images2006 = []
for file in image_files:
    img = Image.open(os.path.join(image_dir, file))
    images2006.append(img)

# prompt: show the images in images folder

import matplotlib.pyplot as plt

# Display the first 25 images
for i in range(len(images2006)):
    plt.imshow(images2006[i])
    plt.show()

"""2012"""

# Define the path to the image dataset (current working directory)
image_dir = '/content/drive/MyDrive/D35(10)/2012'

# Get a list of all image files in the directory
image_files = sorted([f for f in os.listdir(image_dir) if f.endswith('.jpg') or f.endswith('.png')])

# Load the images
images2012 = []
for file in image_files:
    img = Image.open(os.path.join(image_dir, file))
    images2012.append(img)

# Display the first 25 images
for i in range(len(images2012)):
    plt.imshow(images2012[i])
    plt.show()

import cv2
import numpy as np

# Define the geometric registration algorithm
def register_images(img1, img2):
    # Convert images to grayscale
    gray1 = cv2.cvtColor(img1, cv2.COLOR_RGB2GRAY)
    gray2 = cv2.cvtColor(img2, cv2.COLOR_RGB2GRAY)

    # Compute the SIFT features and descriptors for both images
    sift = cv2.SIFT_create()
    kp1, des1 = sift.detectAndCompute(gray1, None)
    kp2, des2 = sift.detectAndCompute(gray2, None)

    # Match the features between the two images
    matcher = cv2.DescriptorMatcher_create(cv2.DESCRIPTOR_MATCHER_BRUTEFORCE)
    matches = list(matcher.match(des1, des2))

    # Sort the matches by distance
    matches.sort(key=lambda x: x.distance)

    # Select the top 10 matches
    matches = matches[:10]

    # Compute the homography matrix from the matches
    src_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)
    homography, _ = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)

    # Apply the homography to the second image
    registered_img = cv2.warpPerspective(img2, homography, (img1.shape[1], img1.shape[0]))

    return registered_img

# Perform geometric registration between consecutive images in the lists
registered_images = []
for i in range(len(images2006)):
    img1 = images2006[i]
    img2 = images2012[i]
    registered_img = register_images(np.array(img1),np.array(img2))
    registered_images.append(registered_img)